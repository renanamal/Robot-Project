#include "my_spi.h"

/***************************************************************************//**
 * @brief
 *    Transfer complete callback function used by blocking transfer API
 *    functions. Called by DMA interrupt handler, timer timeout handler
 *    or @ref SPIDRV_AbortTransfer() function.
 ******************************************************************************/
void my_BlockingComplete(SPIDRV_Handle_t handle,
                             Ecode_t transferStatus,
                             int itemsTransferred)
{
  (void)itemsTransferred;

  handle->transferStatus    = transferStatus;
  handle->blockingCompleted = true;
}


/***************************************************************************//**
 * @brief Parameter checking function for blocking transfer API functions.
 ******************************************************************************/
Ecode_t my_TransferApiBlockingPrologue(SPIDRV_Handle_t handle,
                                           void *buffer,
                                           int count)
{
  CORE_DECLARE_IRQ_STATE;

  if (handle == NULL) {
    return ECODE_EMDRV_SPIDRV_ILLEGAL_HANDLE;
  }

  if ((buffer == NULL) || (count == 0) || (count > DMADRV_MAX_XFER_COUNT)) {
    return ECODE_EMDRV_SPIDRV_PARAM_ERROR;
  }

  CORE_ENTER_ATOMIC();
  if (handle->state != spidrvStateIdle) {
    CORE_EXIT_ATOMIC();
    return ECODE_EMDRV_SPIDRV_BUSY;
  }
  handle->state = spidrvStateTransferring;
  CORE_EXIT_ATOMIC();

  return ECODE_EMDRV_SPIDRV_OK;
}


/***************************************************************************//**
 * @brief Wait for transfer completion.
 ******************************************************************************/
void my_WaitForTransferCompletion(SPIDRV_Handle_t handle)
{
  if (CORE_IrqIsBlocked(SPI_DMA_IRQ)) {
    // Poll for completion by calling IRQ handler.
    while (handle->blockingCompleted == false) {
#if defined(DMA_PRESENT) && (DMA_COUNT == 1)
      DMA_IRQHandler();
#elif defined(LDMA_PRESENT) && (LDMA_COUNT == 1)
      LDMA_IRQHandler();
#else
#error "No valid SPIDRV DMA engine defined."
#endif
    }
  } else {
    while (handle->blockingCompleted == false) ;
  }
}


/***************************************************************************//**
 * @brief
 *    Start an SPI master blocking transfer.
 *
 * @note
 *    This function is blocking and returns when the transfer is complete
 *    or when @ref SPIDRV_AbortTransfer() is called.
 *
 * @param[in]  handle Pointer to an SPI driver handle.
 *
 * @param[in]  txBuffer Transmit data buffer.
 *
 * @param[out] rxBuffer Receive data buffer.
 *
 * @param[in]  count Number of bytes in transfer.
 *
 * @return
 *    @ref ECODE_EMDRV_SPIDRV_OK on success or @ref ECODE_EMDRV_SPIDRV_ABORTED
 *    if @ref SPIDRV_AbortTransfer() has been called. On failure, an appropriate
 *    SPIDRV @ref Ecode_t is returned.
 ******************************************************************************/
Ecode_t my_SPIDRV_MTransferB(SPIDRV_Handle_t handle,
                          const void *txBuffer,
                          void *rxBuffer,
                          int countRX,
                          int countTX)
{
  Ecode_t retVal;

  if (handle->initData.type == spidrvSlave) {
    return ECODE_EMDRV_SPIDRV_MODE_ERROR;
  }

  if ((retVal = my_TransferApiBlockingPrologue(handle, (void*)txBuffer, countTX))
      != ECODE_EMDRV_SPIDRV_OK) {
    return retVal;
  }

  if (rxBuffer == NULL) {
    return ECODE_EMDRV_SPIDRV_PARAM_ERROR;
  }

  my_StartTransferDMA(handle, txBuffer, rxBuffer, countRX, countTX, my_BlockingComplete);

  my_WaitForTransferCompletion(handle);

  return handle->transferStatus;
}


/***************************************************************************//**
 * @brief Power management functions.
 ******************************************************************************/
void my_em1RequestAdd(SPIDRV_Handle_t handle)
{
#if defined(SL_CATALOG_POWER_MANAGER_PRESENT)
  CORE_DECLARE_IRQ_STATE;

  CORE_ENTER_ATOMIC();
  if (handle->em1RequestCount == 0) {
    sl_power_manager_add_em_requirement(SL_POWER_MANAGER_EM1);
  }
  handle->em1RequestCount++;
  CORE_EXIT_ATOMIC();
#else
  handle->em1RequestCount++;
#endif
}



/***************************************************************************//**
 * @brief Start an SPI transmit/receive DMA.
 ******************************************************************************/
void my_StartTransferDMA(SPIDRV_Handle_t handle,
                             const void *txBuffer,
                             void *rxBuffer,
                             int countRX,
                             int countTX,
                             SPIDRV_Callback_t callback)
{
  void *rxPort, *txPort;
  DMADRV_DataSize_t size;

  handle->blockingCompleted  = false;
  handle->transferCount      = countTX;
  handle->userCallback       = callback;

  if (0) {
  }
#if defined(USART_PRESENT)
  else if (handle->peripheralType == spidrvPeripheralTypeUsart) {
    handle->peripheral.usartPort->CMD = USART_CMD_CLEARRX | USART_CMD_CLEARTX;

    if (handle->initData.frameLength > 9) {
      rxPort = (void *)&(handle->peripheral.usartPort->RXDOUBLE);
      txPort = (void *)&(handle->peripheral.usartPort->TXDOUBLE);
    } else if (handle->initData.frameLength == 9) {
      rxPort = (void *)&(handle->peripheral.usartPort->RXDATAX);
      txPort = (void *)&(handle->peripheral.usartPort->TXDATAX);
    } else {
      rxPort = (void *)&(handle->peripheral.usartPort->RXDATA);
      txPort = (void *)&(handle->peripheral.usartPort->TXDATA);
    }
  }
#endif
#if defined(EUSART_PRESENT)
  else if (handle->peripheralType == spidrvPeripheralTypeEusart) {
    clearEusartFifos(handle->peripheral.eusartPort);

    rxPort = (void *)&(handle->peripheral.eusartPort->RXDATA);
    txPort = (void *)&(handle->peripheral.eusartPort->TXDATA);
  }
#endif
  else {
    return;
  }

  if (handle->initData.frameLength > 8) {
    size = dmadrvDataSize2;
  } else {
    size = dmadrvDataSize1;
  }

  my_em1RequestAdd(handle);

  // Start receive DMA.
  DMADRV_PeripheralMemory(handle->rxDMACh,
                          handle->rxDMASignal,
                          rxBuffer,
                          rxPort,
                          true,
                          countRX,
                          size,
                          RxDMAComplete,
                          handle);

  // Start transmit DMA.
  DMADRV_MemoryPeripheral(handle->txDMACh,
                          handle->txDMASignal,
                          txPort,
                          (void*)txBuffer,
                          true,
                          countTX,
                          size,
                          NULL,
                          NULL);
}
